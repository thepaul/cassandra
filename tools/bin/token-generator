#!/usr/bin/env python

import json
import sys
import math
import optparse
from itertools import takewhile

usage = "%prog <nodes_in_dc1> [<nodes_in_dc2> [...]]"

TESTMODE_RINGRANGE = 1000

parser = optparse.OptionParser(usage=usage)
parser.add_option('--ringrange', type='int',
                  help='Specify a numeric maximum token value for your ring, '
                       'different from the default value of 2^127.')

parser.add_option('--test', action='store_true',
                  help='Run in test mode, outputting an HTML file to display '
                       'various generated ring arrangements. Overrides '
                       '--ringrange to be %d.' % TESTMODE_RINGRANGE)

parser.add_option('--test-colors', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-linelength', type='int', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-graphsize', type='int', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-output', help=optparse.SUPPRESS_HELP)

parser.set_defaults(
    ringrange=(1<<127),

    # durr
    test=False,

    # comma-separated list of HTML color codes, used in order to represent
    # respective datacenter nodes
    test_colors='#000,#00F,#0F0,#F00,#0FF,#FF0,#F0F',

    # the length of the rendered per-node rays
    test_linelength=80,

    # size of the per-test graphs
    test_graphsize=100,

    # name of output HTML file to generate, or - for stdout. will clobber
    # any preexisting file!
    test_output='tokentool.html',
)

class Ring:
    def __init__(self, dc_counts, ringrange):
        self.dc_counts = dc_counts
        self.ringrange = ringrange
        self.origtokens = self.calculate_tokens()

    def calculate_tokens(self):
        """Sets the default tokens that each datacenter has to be spaced with."""

        return [[i * self.ringrange // count for i in range(count)] for count in self.dc_counts]

    def add_tokens(self, t1, t2):
        return (t1 + t2) % self.ringrange

    def add_to_all_tokens(self, toklist, offset):
        return [self.add_tokens(t, offset) for t in toklist]

    def neighbor_tokens(self, tokens, this_dc, this_token):
        """
        Returns the tokens immediately preceding and following the given
        token within the ring space, excluding tokens from the same dc.
        """

        preceding = 0
        following = self.ringrange

        for toks in (tokens[:this_dc] + tokens[this_dc+1:]):
            for that_token in toks:
                if preceding < that_token <= this_token:
                    preceding = that_token
                if this_token < that_token < following:
                    following = that_token

        return preceding, following

    def get_offset_tokens(self, offsets):
        """Calculates what the tokens are with their calculated offsets."""
        return map(self.add_to_all_tokens, self.origtokens, offsets)

    def calculate_offset_tokens(self):
        """Find what the offsets should be for each datacenter."""

        offsets = [0] * len(self.origtokens)
        while True:
            tokens = self.get_offset_tokens(offsets)
            oldoffsets = offsets[:]
            for dcnum, dctokens in enumerate(tokens):
                if dcnum == 0 or len(dctokens) == 0:
                    continue
                tokens = self.get_offset_tokens(offsets)

                # Get all the offsets, per token, that place each token in the ideal spot
                # away from all other tokens in the cluster
                running_offset_sum = 0
                for this_token in dctokens:
                    preceding, following = self.neighbor_tokens(tokens, dcnum, this_token)
                    perfect_spot = (following + preceding) // 2
                    running_offset_sum += perfect_spot - this_token

                # Set this datacenters offset to be an average of all the running offsets
                offsets[dcnum] += running_offset_sum // len(dctokens)

            # Only exit the loop none of the offsets increased
            if all(newoff <= oldoff for (newoff, oldoff) in zip(offsets, oldoffsets)):
                return tokens


def print_tokens(tokens):
    print json.dumps(tokens, sort_keys=True, indent=4)

def calculate_ideal_tokens(datacenters, ringrange):
    # Calculate the amount of datacenters in the beginning
    # of the list that have no nodes
    # Because the first DC remains stable
    leading_blank_datacenters = len(list(takewhile(lambda x: x==0, datacenters)))
    ring = Ring(datacenters[leading_blank_datacenters:], ringrange=ringrange)

    offset_tokens = ring.calculate_offset_tokens()

    # Add the preceding blank datacenters back in
    return [[]] * leading_blank_datacenters + offset_tokens


# ===========================
# Tests

html_template = """<!DOCTYPE html>
<html>
<body>

%s

</body>
</html>
"""

chart_template = """
<canvas id="{0}" width="{2}" height="{2}" style="border:1px solid #c3c3c3;">
    Your browser does not support the canvas element.
</canvas>
<script type="text/javascript">
    var c=document.getElementById("{0}");
    var ctx=c.getContext("2d");
%s
</script>
"""

chart_piece_template = """
    ctx.beginPath();
    ctx.strokeStyle = "%s";
    ctx.moveTo({1},{1});
    ctx.lineTo(%s,%s);
    ctx.stroke();
    ctx.closePath();
"""

class RingRenderer:
    def __init__(self, ringrange, linelength, graphsize, colors):
        self.ringrange = ringrange
        self.linelength = linelength
        self.graphsize = graphsize
        self.colors = colors

    def calc_tests(self, tokens):
        these_calcs = []

        for toklist in tokens:
            coordlist = []
            for tok in toklist:
                degrees = (tok * 360 / self.ringrange) + 180
                radians = degrees * math.pi / 180

                center = self.graphsize
                x2 = center + self.linelength * math.sin(radians);
                y2 = center + self.linelength * math.cos(radians);
                coordlist.append((x2, y2))
            these_calcs.append(coordlist)

        return these_calcs

    def write_html(self, coordinate_sets, output=sys.stdout):
        all_charts = ''
        for chart_set in range(len(coordinate_sets)):
            chart_index = chart_set
            chart_set = coordinate_sets[chart_set]
            chart_piece = ''
            for dc in range(len(chart_set)):
                for x, y in chart_set[dc]:
                    chart_piece += chart_piece_template % (self.colors[dc], x, y)
            this_chart = chart_template % chart_piece
            all_charts += this_chart.format(chart_index, self.graphsize, self.graphsize * 2)
        output.write(html_template % all_charts)

def run_tests(opts):
    colorlist = [s.strip() for s in opts.test_colors.split(',')]
    renderer = RingRenderer(ringrange=opts.ringrange, linelength=opts.test_linelength,
                            graphsize=opts.test_graphsize, colors=colorlist)

    tests = [
        [1],
        [1, 1],
        [2, 2],
        [1, 2, 2],
        [2, 2, 2],
        [2, 0, 0],
        [0, 2, 0],
        [0, 0, 2],
        [2, 2, 0],
        [2, 0, 2],
        [0, 2, 2],
        [0, 0, 1, 1, 0, 1, 1],
        [6],
        [3, 3, 3],
        [9],
        [1,1,1,1],
        [4],
        [3,3,6,4,2]
    ]

    test_coord_sets = []
    for test in tests:
        tokens = calculate_ideal_tokens(test, opts.ringrange)
        print_tokens(tokens)
        test_coord_sets.append(renderer.calc_tests(tokens))

    with open(opts.test_output, 'w') as f:
        renderer.write_html(test_coord_sets, f)

# ===========================

if __name__ == '__main__':
    opts, args = parser.parse_args()

    if opts.test_output == '-':
        opts.test_output = '/dev/stdout'
    if opts.test:
        opts.ringrange = TESTMODE_RINGRANGE
        run_tests(opts)
        sys.exit(0)

    if len(args) == 0:
        parser.error('No datacenter sizes given.')

    try:
        datacenters = map(int, args)
    except ValueError, e:
        parser.error('Arguments should be integers.')

    print_tokens(calculate_ideal_tokens(datacenters, opts.ringrange))
