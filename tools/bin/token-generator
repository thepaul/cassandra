#!/usr/bin/env python

import json
import sys
import math
import optparse
from itertools import takewhile

usage = "%prog <nodes_in_dc1> [<nodes_in_dc2> [...]]"

parser = optparse.OptionParser(usage=usage)
parser.add_option('--ringrange', type='int',
                  help='Specify a numeric maximum token value for your ring, '
                       'different from the default value of 2^127.')

parser.add_option('--test', action='store_true',
                  help='Run in test mode, outputting an HTML file to display '
                       'various generated ring arrangements.')

parser.add_option('--test-colors', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-linelength', type='int', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-graphsize', type='int', help=optparse.SUPPRESS_HELP)
parser.add_option('--test-output', help=optparse.SUPPRESS_HELP)

parser.set_defaults(
    ringrange=(1<<127),

    # durr
    test=False,

    # comma-separated list of HTML color codes, used in order to represent
    # respective datacenter nodes
    test_colors='#000,#00F,#0F0,#F00,#0FF,#FF0,#F0F',

    # the length of the rendered per-node rays
    test_linelength=80,

    # size of the per-test graphs
    test_graphsize=100,

    # name of output HTML file to generate, or - for stdout. will clobber
    # any preexisting file!
    test_output='tokentool.html',
)

class Ring:
    def __init__(self, dc_counts, ringrange):
        self.ringrange = ringrange
        self.origtokens = self.calculate_tokens(dc_counts)

    def calculate_tokens(self, dc_counts):
        """Sets the default tokens that each datacenter has to be spaced with."""

        return [[i * self.ringrange // count for i in range(count)] for count in dc_counts]

    def calculate_offset_tokens(self):
        alltoks = [(t, dc) for (dc, toks) in enumerate(self.origtokens) for t in toks]
        final = [[] for x in self.origtokens]
        for pos, (t, dc) in enumerate(sorted(alltoks)):
            final[dc].append(pos * self.ringrange // len(alltoks))
        return final


def print_tokens(tokens, opts, indent=0):
    toklen = len(str(opts.ringrange)) + 1
    indentstr = ' ' * indent
    for dcnum, toklist in enumerate(tokens):
        print "%sDC #%d:" % (indentstr, dcnum + 1)
        for tnum, tok in enumerate(toklist):
            print "%s  Node #%d: % *d" % (indentstr, tnum + 1, toklen, tok)

def calculate_ideal_tokens(datacenters, ringrange):
    return Ring(datacenters, ringrange).calculate_offset_tokens()


# ===========================
# Tests

html_template = """<!DOCTYPE html>
<html>
<body>

%s

</body>
</html>
"""

chart_template = """
<canvas id="{0}" width="{2}" height="{2}" style="border:1px solid #c3c3c3;">
    Your browser does not support the canvas element.
</canvas>
<script type="text/javascript">
    var c=document.getElementById("{0}");
    var ctx=c.getContext("2d");
%s
</script>
"""

chart_piece_template = """
    ctx.beginPath();
    ctx.strokeStyle = "%s";
    ctx.moveTo({1},{1});
    ctx.lineTo(%s,%s);
    ctx.stroke();
    ctx.closePath();
"""

class RingRenderer:
    def __init__(self, ringrange, linelength, graphsize, colors):
        self.ringrange = ringrange
        self.linelength = linelength
        self.graphsize = graphsize
        self.colors = colors

    def calc_tests(self, tokens):
        these_calcs = []

        for toklist in tokens:
            coordlist = []
            for tok in toklist:
                degrees = (tok * 360 / self.ringrange) + 180
                radians = degrees * math.pi / 180

                center = self.graphsize
                x2 = center + self.linelength * math.sin(radians);
                y2 = center + self.linelength * math.cos(radians);
                coordlist.append((x2, y2))
            these_calcs.append(coordlist)

        return these_calcs

    def write_html(self, coordinate_sets, output=sys.stdout):
        all_charts = ''
        for chart_set in range(len(coordinate_sets)):
            chart_index = chart_set
            chart_set = coordinate_sets[chart_set]
            chart_piece = ''
            for dc in range(len(chart_set)):
                for x, y in chart_set[dc]:
                    chart_piece += chart_piece_template % (self.colors[dc], x, y)
            this_chart = chart_template % chart_piece
            all_charts += this_chart.format(chart_index, self.graphsize, self.graphsize * 2)
        output.write(html_template % all_charts)

def run_tests(opts):
    colorlist = [s.strip() for s in opts.test_colors.split(',')]
    renderer = RingRenderer(ringrange=opts.ringrange, linelength=opts.test_linelength,
                            graphsize=opts.test_graphsize, colors=colorlist)

    tests = [
        [1],
        [1, 1],
        [2, 2],
        [1, 2, 2],
        [2, 2, 2],
        [2, 0, 0],
        [0, 2, 0],
        [0, 0, 2],
        [2, 2, 0],
        [2, 0, 2],
        [0, 2, 2],
        [0, 0, 1, 1, 0, 1, 1],
        [6],
        [3, 3, 3],
        [9],
        [1,1,1,1],
        [4],
        [3,3,6,4,2]
    ]

    test_coord_sets = []
    for test in tests:
        print "Test %r" % (test,)
        tokens = calculate_ideal_tokens(test, opts.ringrange)
        print_tokens(tokens, opts, indent=2)
        test_coord_sets.append(renderer.calc_tests(tokens))

    with open(opts.test_output, 'w') as f:
        renderer.write_html(test_coord_sets, f)

# ===========================

if __name__ == '__main__':
    opts, args = parser.parse_args()

    if opts.test_output == '-':
        opts.test_output = '/dev/stdout'
    if opts.test:
        run_tests(opts)
        sys.exit(0)

    if len(args) == 0:
        parser.error('No datacenter sizes given.')

    try:
        datacenters = map(int, args)
    except ValueError, e:
        parser.error('Arguments should be integers.')

    print_tokens(calculate_ideal_tokens(datacenters, opts.ringrange), opts)
